<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Murmure: ZoneGen Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Murmure
   </div>
   <div id="projectbrief">Rogue-lite twin-stick shooter</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classZoneGen-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ZoneGen Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>TODO : Finir la doc de <a class="el" href="classZoneGen.html" title="TODO : Finir la doc de ZoneGen... ">ZoneGen</a>...  
 <a href="classZoneGen.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ZoneGen_8h_source.html">ZoneGen.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aae2af3fc6b6db23a7b1f7091115ef392"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZoneGen.html#aae2af3fc6b6db23a7b1f7091115ef392">ZoneGen</a> ()</td></tr>
<tr class="memdesc:aae2af3fc6b6db23a7b1f7091115ef392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur par défaut Initialise toute la carte sur 0, met le <em>patterne</em> et la <em>methode</em> comme " " et place <em>valide</em> et <em>pret_iteration</em> sur false.  <a href="#aae2af3fc6b6db23a7b1f7091115ef392">More...</a><br /></td></tr>
<tr class="separator:aae2af3fc6b6db23a7b1f7091115ef392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893e3c5d0ae5ecc50bf19a5d90e89b45"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZoneGen.html#a893e3c5d0ae5ecc50bf19a5d90e89b45">get_etat</a> (int x, int y) const </td></tr>
<tr class="memdesc:a893e3c5d0ae5ecc50bf19a5d90e89b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesseur d'une 'salle' de la grille.  <a href="#a893e3c5d0ae5ecc50bf19a5d90e89b45">More...</a><br /></td></tr>
<tr class="separator:a893e3c5d0ae5ecc50bf19a5d90e89b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e073b705a18999388b0b85b7c11a080"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZoneGen.html#a0e073b705a18999388b0b85b7c11a080">is_valide</a> () const </td></tr>
<tr class="memdesc:a0e073b705a18999388b0b85b7c11a080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesseur de <em>valide</em>.  <a href="#a0e073b705a18999388b0b85b7c11a080">More...</a><br /></td></tr>
<tr class="separator:a0e073b705a18999388b0b85b7c11a080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64697de6f96b242b2fb191af66e1a30"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZoneGen.html#ac64697de6f96b242b2fb191af66e1a30">get_posx_dep</a> () const </td></tr>
<tr class="memdesc:ac64697de6f96b242b2fb191af66e1a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesseur de <em>posx_dep</em>. posx_dep est la coordonnee x de la case de depart de la <em>carte</em>.  <a href="#ac64697de6f96b242b2fb191af66e1a30">More...</a><br /></td></tr>
<tr class="separator:ac64697de6f96b242b2fb191af66e1a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a3a729f5d2106dbb47f33aa4d8bc9a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZoneGen.html#aa8a3a729f5d2106dbb47f33aa4d8bc9a">get_posy_dep</a> () const </td></tr>
<tr class="memdesc:aa8a3a729f5d2106dbb47f33aa4d8bc9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesseur de <em>posy_dep</em>. posx_dep est la coordonnee y de la case de depart de la <em>carte</em>.  <a href="#aa8a3a729f5d2106dbb47f33aa4d8bc9a">More...</a><br /></td></tr>
<tr class="separator:aa8a3a729f5d2106dbb47f33aa4d8bc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76588fc3a5d361a213ec28692b8abcdc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZoneGen.html#a76588fc3a5d361a213ec28692b8abcdc">get_nb_cases</a> () const </td></tr>
<tr class="memdesc:a76588fc3a5d361a213ec28692b8abcdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">'Accesseur' du nombre de cases de <em>carte</em>.  <a href="#a76588fc3a5d361a213ec28692b8abcdc">More...</a><br /></td></tr>
<tr class="separator:a76588fc3a5d361a213ec28692b8abcdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881eb249ee86fa522c58e7f42f651c85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZoneGen.html#a881eb249ee86fa522c58e7f42f651c85">teste_nb_cases_assez</a> (int nb_voulu)</td></tr>
<tr class="memdesc:a881eb249ee86fa522c58e7f42f651c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vérifie que la nombre de cases est suffisant. fait appel à <a class="el" href="classZoneGen.html#a76588fc3a5d361a213ec28692b8abcdc" title="&#39;Accesseur&#39; du nombre de cases de carte. ">get_nb_cases()</a> et passe <em>valide</em> sur false si la <em>carte</em> contient plus de nb_voulu cases.  <a href="#a881eb249ee86fa522c58e7f42f651c85">More...</a><br /></td></tr>
<tr class="separator:a881eb249ee86fa522c58e7f42f651c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47825d838930c2f8657044353767f222"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZoneGen.html#a47825d838930c2f8657044353767f222">teste_nb_cases_trop</a> (int nb_voulu)</td></tr>
<tr class="memdesc:a47825d838930c2f8657044353767f222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vérifie que la nombre de cases n'est pas trop grand. fait appel à <a class="el" href="classZoneGen.html#a76588fc3a5d361a213ec28692b8abcdc" title="&#39;Accesseur&#39; du nombre de cases de carte. ">get_nb_cases()</a> et passe <em>valide</em> sur false si la <em>carte</em> contient moins de nb_voulu cases.  <a href="#a47825d838930c2f8657044353767f222">More...</a><br /></td></tr>
<tr class="separator:a47825d838930c2f8657044353767f222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08565e6eb38911c72143aacfced7b91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZoneGen.html#aa08565e6eb38911c72143aacfced7b91">initialisation_gen</a> (std::string pat, std::string met)</td></tr>
<tr class="memdesc:aa08565e6eb38911c72143aacfced7b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise la <em>carte</em> avec le patterne voulu. passe <em>pret_iteration</em> sur true après avoir vérifié que le <em>patterne</em> et la <em>methode</em> sont correctes, et charge le patterne depuis un <a class="el" href="classFichier.html">Fichier</a> avant de l'appliquer à la <em>carte</em>.  <a href="#aa08565e6eb38911c72143aacfced7b91">More...</a><br /></td></tr>
<tr class="separator:aa08565e6eb38911c72143aacfced7b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79aa554fa5bee5bd1e0af2a1a505fa57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZoneGen.html#a79aa554fa5bee5bd1e0af2a1a505fa57">afficher_carte</a> () const </td></tr>
<tr class="memdesc:a79aa554fa5bee5bd1e0af2a1a505fa57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Affiche la carte dans la console. une procédure très certainement éphémère.  <a href="#a79aa554fa5bee5bd1e0af2a1a505fa57">More...</a><br /></td></tr>
<tr class="separator:a79aa554fa5bee5bd1e0af2a1a505fa57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63dfaff24d4686702b22937606da1e04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZoneGen.html#a63dfaff24d4686702b22937606da1e04">iterer</a> (std::string meth=&quot;&quot;)</td></tr>
<tr class="memdesc:a63dfaff24d4686702b22937606da1e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Itère sur le modèle avec la <em>methode</em> choisie. Procédure d'itération sur le generateur, qui parcours la <em>carte</em> dans le sens de la lecture, et applique des changements selon la <em>methode</em> d'iteration.  <a href="#a63dfaff24d4686702b22937606da1e04">More...</a><br /></td></tr>
<tr class="separator:a63dfaff24d4686702b22937606da1e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d84dcb2654e8339cd325cf15fcf9ca"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZoneGen.html#ab1d84dcb2654e8339cd325cf15fcf9ca">get_patterne</a> ()</td></tr>
<tr class="memdesc:ab1d84dcb2654e8339cd325cf15fcf9ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesseur du <em>patterne</em> de l'instance.  <a href="#ab1d84dcb2654e8339cd325cf15fcf9ca">More...</a><br /></td></tr>
<tr class="separator:ab1d84dcb2654e8339cd325cf15fcf9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b87a471d137c8db268ffc2df0425c81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZoneGen.html#a6b87a471d137c8db268ffc2df0425c81">set_etat</a> (int i, int j, int etat)</td></tr>
<tr class="memdesc:a6b87a471d137c8db268ffc2df0425c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutateur d'une 'salle' de la <em>carte</em> (int).  <a href="#a6b87a471d137c8db268ffc2df0425c81">More...</a><br /></td></tr>
<tr class="separator:a6b87a471d137c8db268ffc2df0425c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f167f538f4e9f3e12908421297250f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZoneGen.html#ad0f167f538f4e9f3e12908421297250f">valider</a> ()</td></tr>
<tr class="memdesc:ad0f167f538f4e9f3e12908421297250f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procédure de validation de la <em>carte</em>. Recopie <em>carte</em> dans <em>carte_validation</em>, puis cherche une salle pour commencer la récursivité et appelle valider_recursif() sur cette salle. Ensuite, vérifie que toutes les salles sont peintes et détermine l'état de validité de la <em>carte</em>.  <a href="#ad0f167f538f4e9f3e12908421297250f">More...</a><br /></td></tr>
<tr class="separator:ad0f167f538f4e9f3e12908421297250f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57bde599d7912da9ee574d5f94c3ea48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZoneGen.html#a57bde599d7912da9ee574d5f94c3ea48">afficher_validation</a> () const </td></tr>
<tr class="memdesc:a57bde599d7912da9ee574d5f94c3ea48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Affiche <em>carte_validation</em> dans la console (txt) Ceci est une procédure de test &ndash; elle est à détruire en release.  <a href="#a57bde599d7912da9ee574d5f94c3ea48">More...</a><br /></td></tr>
<tr class="separator:a57bde599d7912da9ee574d5f94c3ea48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e14ba96367ade514d250c4ae1aa5025"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZoneGen.html#a2e14ba96367ade514d250c4ae1aa5025">placer_boss</a> ()</td></tr>
<tr class="memdesc:a2e14ba96367ade514d250c4ae1aa5025"><td class="mdescLeft">&#160;</td><td class="mdescRight">place une salle de boss dans la <em>carte</em>. La recherche de boss se fait ainsi : une variable aleatoire decide en premier lieu si la recherche se fait dans le sens de lecture ou dans le sens inverse (pour plus de variation). Ensuite, on cherche une salle n'ayant qu'une seule salle adjacente. Si aucune salle n'est valable, l'attribut <em>valide</em> est passé sur false (ce qui implique que la carte est invalidée et repasse à la génération).  <a href="#a2e14ba96367ade514d250c4ae1aa5025">More...</a><br /></td></tr>
<tr class="separator:a2e14ba96367ade514d250c4ae1aa5025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab288110fafd009f569ab27d65d35b3ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZoneGen.html#ab288110fafd009f569ab27d65d35b3ed">vider_carte</a> ()</td></tr>
<tr class="memdesc:ab288110fafd009f569ab27d65d35b3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">vide la <em>carte</em>. Met toute la <em>carte</em> sur 0, et passe <em>pret_iteration</em> sur false.  <a href="#ab288110fafd009f569ab27d65d35b3ed">More...</a><br /></td></tr>
<tr class="separator:ab288110fafd009f569ab27d65d35b3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf5a70af191ddd5f5875878831a5b63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZoneGen.html#aadf5a70af191ddd5f5875878831a5b63">placer_depart</a> ()</td></tr>
<tr class="memdesc:aadf5a70af191ddd5f5875878831a5b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place la salle de départ. Fonctionne sur le même principe que <a class="el" href="classZoneGen.html#a2e14ba96367ade514d250c4ae1aa5025" title="place une salle de boss dans la carte. La recherche de boss se fait ainsi : une variable aleatoire de...">placer_boss()</a>. Cherche une salle avec 4 salles adjacentes. Mais s'il n'en existe pas, place le départ aléatoirement au lieu d'invalider la carte.  <a href="#aadf5a70af191ddd5f5875878831a5b63">More...</a><br /></td></tr>
<tr class="separator:aadf5a70af191ddd5f5875878831a5b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f00aefb1e1c0a33bddeda26c9168ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZoneGen.html#a14f00aefb1e1c0a33bddeda26c9168ca">placer_clef</a> ()</td></tr>
<tr class="memdesc:a14f00aefb1e1c0a33bddeda26c9168ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place la clef du boss. La clef du boss est toujours le plus loin possible du départ (ce qui implique qu'elle sera parfois à côté du boss). La procédure utilise donc logiquement calculer_distance().  <a href="#a14f00aefb1e1c0a33bddeda26c9168ca">More...</a><br /></td></tr>
<tr class="separator:a14f00aefb1e1c0a33bddeda26c9168ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56263320aa237d125e4737c21a4c6fa6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classZoneGen.html#a56263320aa237d125e4737c21a4c6fa6">placer_objet</a> ()</td></tr>
<tr class="memdesc:a56263320aa237d125e4737c21a4c6fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place une salle d'objet. L'objet est simplement placé sur une salle aléatoirement, pourvu qu'elle ne soit pas déjà utilisée à d'autres fins.  <a href="#a56263320aa237d125e4737c21a4c6fa6">More...</a><br /></td></tr>
<tr class="separator:a56263320aa237d125e4737c21a4c6fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>TODO : Finir la doc de <a class="el" href="classZoneGen.html" title="TODO : Finir la doc de ZoneGen... ">ZoneGen</a>... </p>
<p>class principale de generation de carte pour <a class="el" href="classZone.html" title="Gère l&#39;instance où crapahute Perso. Une seule Zone sera en général générée à chaque instant...">Zone</a>. <a class="el" href="classZoneGen.html" title="TODO : Finir la doc de ZoneGen... ">ZoneGen</a> est une classe de transition entre <a class="el" href="classModele.html" title="class gerant une ZoneGen pour generer une Zone facilement. Grace à Modele, il est possible de créer e...">Modele</a> et <a class="el" href="classZone.html" title="Gère l&#39;instance où crapahute Perso. Une seule Zone sera en général générée à chaque instant...">Zone</a>, instanciant un generateur contenant une carte semblable aux Zones. Le generateur applique un patterne de base sur sa carte, puis 'itere' dessus avec differentes methodes. une procedure permet ensuite de <a class="el" href="classZoneGen.html#ad0f167f538f4e9f3e12908421297250f" title="Procédure de validation de la carte. Recopie carte dans carte_validation, puis cherche une salle pour...">valider()</a> la carte, en verifiant que toutes les salles sont connectees, puis place le boss et l'objet de la <a class="el" href="classZone.html" title="Gère l&#39;instance où crapahute Perso. Une seule Zone sera en général générée à chaque instant...">Zone</a>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aae2af3fc6b6db23a7b1f7091115ef392"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ZoneGen::ZoneGen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructeur par défaut Initialise toute la carte sur 0, met le <em>patterne</em> et la <em>methode</em> comme " " et place <em>valide</em> et <em>pret_iteration</em> sur false. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a79aa554fa5bee5bd1e0af2a1a505fa57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ZoneGen::afficher_carte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Affiche la carte dans la console. une procédure très certainement éphémère. </p>

</div>
</div>
<a class="anchor" id="a57bde599d7912da9ee574d5f94c3ea48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ZoneGen::afficher_validation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Affiche <em>carte_validation</em> dans la console (txt) Ceci est une procédure de test &ndash; elle est à détruire en release. </p>

</div>
</div>
<a class="anchor" id="a893e3c5d0ae5ecc50bf19a5d90e89b45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ZoneGen::get_etat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accesseur d'une 'salle' de la grille. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: coordonnees x de la salle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>: coordonnees y de la salle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>l'entier correspondant à la 'salle' x,y. </dd></dl>

</div>
</div>
<a class="anchor" id="a76588fc3a5d361a213ec28692b8abcdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ZoneGen::get_nb_cases </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>'Accesseur' du nombre de cases de <em>carte</em>. </p>
<dl class="section return"><dt>Returns</dt><dd>le nombre de cases composant la <em>carte</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab1d84dcb2654e8339cd325cf15fcf9ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ZoneGen::get_patterne </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accesseur du <em>patterne</em> de l'instance. </p>
<dl class="section return"><dt>Returns</dt><dd>le <em>patterne</em> de <a class="el" href="classZoneGen.html" title="TODO : Finir la doc de ZoneGen... ">ZoneGen</a> (string). </dd></dl>

</div>
</div>
<a class="anchor" id="ac64697de6f96b242b2fb191af66e1a30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ZoneGen::get_posx_dep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accesseur de <em>posx_dep</em>. posx_dep est la coordonnee x de la case de depart de la <em>carte</em>. </p>
<dl class="section return"><dt>Returns</dt><dd>l'attribut <em>posx_dep</em> de l'instance. </dd></dl>

</div>
</div>
<a class="anchor" id="aa8a3a729f5d2106dbb47f33aa4d8bc9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ZoneGen::get_posy_dep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accesseur de <em>posy_dep</em>. posx_dep est la coordonnee y de la case de depart de la <em>carte</em>. </p>
<dl class="section return"><dt>Returns</dt><dd>l'attribut <em>posy_dep</em> de l'instance. </dd></dl>

</div>
</div>
<a class="anchor" id="aa08565e6eb38911c72143aacfced7b91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ZoneGen::initialisation_gen </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>met</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise la <em>carte</em> avec le patterne voulu. passe <em>pret_iteration</em> sur true après avoir vérifié que le <em>patterne</em> et la <em>methode</em> sont correctes, et charge le patterne depuis un <a class="el" href="classFichier.html">Fichier</a> avant de l'appliquer à la <em>carte</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pat</td><td>: le nom du <em>patterne</em> à utiliser : carré, croix, etc.. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">met</td><td>: le nom de <em>la</em> methode à utiliser : voisins, aleatoire, etc.. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e073b705a18999388b0b85b7c11a080"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ZoneGen::is_valide </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accesseur de <em>valide</em>. </p>
<dl class="section return"><dt>Returns</dt><dd>l'état de validité de la <em>carte</em> du generateur. </dd></dl>

</div>
</div>
<a class="anchor" id="a63dfaff24d4686702b22937606da1e04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ZoneGen::iterer </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>meth</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Itère sur le modèle avec la <em>methode</em> choisie. Procédure d'itération sur le generateur, qui parcours la <em>carte</em> dans le sens de la lecture, et applique des changements selon la <em>methode</em> d'iteration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meth</td><td>: <em>methode</em> à appliquer pour l'iteration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2e14ba96367ade514d250c4ae1aa5025"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ZoneGen::placer_boss </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>place une salle de boss dans la <em>carte</em>. La recherche de boss se fait ainsi : une variable aleatoire decide en premier lieu si la recherche se fait dans le sens de lecture ou dans le sens inverse (pour plus de variation). Ensuite, on cherche une salle n'ayant qu'une seule salle adjacente. Si aucune salle n'est valable, l'attribut <em>valide</em> est passé sur false (ce qui implique que la carte est invalidée et repasse à la génération). </p>

</div>
</div>
<a class="anchor" id="a14f00aefb1e1c0a33bddeda26c9168ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ZoneGen::placer_clef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place la clef du boss. La clef du boss est toujours le plus loin possible du départ (ce qui implique qu'elle sera parfois à côté du boss). La procédure utilise donc logiquement calculer_distance(). </p>

</div>
</div>
<a class="anchor" id="aadf5a70af191ddd5f5875878831a5b63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ZoneGen::placer_depart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place la salle de départ. Fonctionne sur le même principe que <a class="el" href="classZoneGen.html#a2e14ba96367ade514d250c4ae1aa5025" title="place une salle de boss dans la carte. La recherche de boss se fait ainsi : une variable aleatoire de...">placer_boss()</a>. Cherche une salle avec 4 salles adjacentes. Mais s'il n'en existe pas, place le départ aléatoirement au lieu d'invalider la carte. </p>

</div>
</div>
<a class="anchor" id="a56263320aa237d125e4737c21a4c6fa6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ZoneGen::placer_objet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place une salle d'objet. L'objet est simplement placé sur une salle aléatoirement, pourvu qu'elle ne soit pas déjà utilisée à d'autres fins. </p>

</div>
</div>
<a class="anchor" id="a6b87a471d137c8db268ffc2df0425c81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ZoneGen::set_etat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>etat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mutateur d'une 'salle' de la <em>carte</em> (int). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>: coordonnee x de la 'salle'. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>: coordonnee y de la 'salle'. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">salle</td><td>: l'int qui remplacera le carte[i][j] actuel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a881eb249ee86fa522c58e7f42f651c85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ZoneGen::teste_nb_cases_assez </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_voulu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vérifie que la nombre de cases est suffisant. fait appel à <a class="el" href="classZoneGen.html#a76588fc3a5d361a213ec28692b8abcdc" title="&#39;Accesseur&#39; du nombre de cases de carte. ">get_nb_cases()</a> et passe <em>valide</em> sur false si la <em>carte</em> contient plus de nb_voulu cases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_voulu</td><td>: le nbre maximum de cases voulues. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a47825d838930c2f8657044353767f222"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ZoneGen::teste_nb_cases_trop </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_voulu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vérifie que la nombre de cases n'est pas trop grand. fait appel à <a class="el" href="classZoneGen.html#a76588fc3a5d361a213ec28692b8abcdc" title="&#39;Accesseur&#39; du nombre de cases de carte. ">get_nb_cases()</a> et passe <em>valide</em> sur false si la <em>carte</em> contient moins de nb_voulu cases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_voulu</td><td>: le nbre minimum de cases voulues. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad0f167f538f4e9f3e12908421297250f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ZoneGen::valider </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Procédure de validation de la <em>carte</em>. Recopie <em>carte</em> dans <em>carte_validation</em>, puis cherche une salle pour commencer la récursivité et appelle valider_recursif() sur cette salle. Ensuite, vérifie que toutes les salles sont peintes et détermine l'état de validité de la <em>carte</em>. </p>

</div>
</div>
<a class="anchor" id="ab288110fafd009f569ab27d65d35b3ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ZoneGen::vider_carte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>vide la <em>carte</em>. Met toute la <em>carte</em> sur 0, et passe <em>pret_iteration</em> sur false. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/quentin/Murmure/src/core/<a class="el" href="ZoneGen_8h_source.html">ZoneGen.h</a></li>
<li>/home/quentin/Murmure/src/core/<a class="el" href="ZoneGen_8cpp.html">ZoneGen.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
